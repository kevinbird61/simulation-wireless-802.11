<!-- "doc" type, with tabs usage as template--><!-- Author: Kevin Cyu--><!-- include mixins--><!-- mixin - list--><!-- main--><!DOCTYPE html><html><!-- include header--><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Project 2</title><link rel="stylesheet" href="./asset/highlight.min.css"/><link rel="stylesheet" href="./asset/paper.min.css"/><link rel="stylesheet" href="./asset/monokai.css"/><link rel="stylesheet" href="./asset/main.css"/><link rel="stylesheet" href="./asset/cn-font.css"/><style>.tabs input[id=tab6]:checked~div[id=content6]{display:block}</style><style>.tabs input[id=tab7]:checked~div[id=content7]{display:block}</style><style>.tabs input[id=tab8]:checked~div[id=content8]{display:block}</style><style>.tabs input[id=tab9]:checked~div[id=content9]{display:block}</style><style>.tabs input[id=tab10]:checked~div[id=content10]{display:block}</style><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="./asset/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="container"><div class="paper"><div class="demo-title" id="top"><div class="row flex-center"><div class="text-center"> <h1>Project 2</h1></div></div></div><div class="section"><div class="flex-spaces tabs">
<input id="tab1" type="radio" name="tabs" checked/>
<label for="tab1">01-Intro</label>

<input id="tab2" type="radio" name="tabs"/>
<label for="tab2">02-1-Radio</label>

<input id="tab3" type="radio" name="tabs"/>
<label for="tab3">02-2-Mobility</label>

<input id="tab4" type="radio" name="tabs"/>
<label for="tab4">02-3-PHY</label>

<input id="tab5" type="radio" name="tabs"/>
<label for="tab5">02-4-NET</label>

<input id="tab6" type="radio" name="tabs"/>
<label for="tab6">02-5-APP</label>

<input id="tab7" type="radio" name="tabs"/>
<label for="tab7">02-6-MAC</label>

<input id="tab8" type="radio" name="tabs"/>
<label for="tab8">02-source-code-tracing</label>

<input id="tab9" type="radio" name="tabs"/>
<label for="tab9">03-event</label>

<input id="tab10" type="radio" name="tabs"/>
<label for="tab10">04-Util</label>

<div class="content" id="content1"><p><h2>Introduction</h2>
<p>Project 2 is aim to anaylze the source code of 802.11 mechanism. Using MATLAB source code to illustrate how does it work.</p>
<p>Obviously, the work can be divided into several part:</p>
<ol>
<li>Power consumption (Radio Propagation, Mobility, PHY)
<ul>
<li>transmition rate</li>
<li>transmition power</li>
<li>distance</li>
</ul>
</li>
<li>Interference among nodes (NET, APP)
<ul>
<li>overlay</li>
</ul>
</li>
<li>Internal receiving mechanism in each node. (MAC)
<ul>
<li>contention window mechanism</li>
<li>re-transmit mechanism</li>
</ul>
</li>
</ol>
<h2>Note</h2>
<ul>
<li>This project is used for NCKU network simulation course, use for education only.</li>
<li>Written by <a href="https://github.com/kevinbird61"><code>Kevin Cyu</code></a>
<ul>
<li><code>Nuntanut Bhooanusas</code></li>
<li><code>JingZhao Zhuo</code></li>
</ul>
</li>
</ul>
</p></div><div class="content" id="content2"><p><h2>Radio Propagation</h2>
<p>Edit: <code>Kevin Cyu</code></p>
<hr>
<p>This part introduce <code>3 model</code> on power delivery:</p>
<ul>
<li>free space propagation</li>
<li>two-ray ground reflection model</li>
<li>lognormal shadowing model</li>
</ul>
<h3>Free Space</h3>
<ul>
<li>transmit/receive antenna <strong>without any influence of the earth surface</strong> , so called “free space”</li>
<li>Equation: <code>w = pT * Gt/ (4 * p * d^2).</code>, is the power which this transmitter can provide.
<ul>
<li>d: antenna coverage range</li>
<li>pT : power ( transmitter )</li>
<li>Gt : antenna gain</li>
<li>4 p d2 : coverage area size</li>
</ul>
</li>
<li>This equation represent an <code>sphere</code>, where transmitter is in the <code>center</code>, and the <code>radius</code> is <code>d</code>
<ul>
<li><code>4 p d^2</code> is the area which the power delivery by transmitter can reach.</li>
</ul>
</li>
</ul>
<h4>Path Loss Theorem</h4>
<ul>
<li>When distance of propagation increase, the radiated <code>energy</code> will decrease, so called <code>path loss</code>
<ul>
<li>power and <code>d^2</code> is inversely(成反比).</li>
</ul>
</li>
</ul>
<pre><code>P' = P - 20*log(d'/d)
</code></pre>
<h3>Two-ray ground reflection model</h3>
<ul>
<li>A more realistic model compare to <code>free space</code></li>
<li>Not only calculate the transmission of node to node, also consider the <code>reflection</code> of from the earth.</li>
<li>In this model, the result in <code>short-distance</code> is worse because the <strong>oscillation combination from constructive and destructive ray</strong>.</li>
</ul>
<h3>Lognormal shadowing model</h3>
<ul>
<li>The above 2 model are all in the ideal case in <code>cycle</code>.</li>
<li>Practically, received power will be an <code>random variable</code> which based on <code>multi-path propagation</code> in the specific distance, a.k.a <code>fading effects</code>
<ul>
<li>Need to consider: <code>path loss model</code>, <code>variation of received power(in specific distance)</code></li>
</ul>
</li>
<li><code>shadowing model</code> extends the ideal circle model to a sophisticated model, a more realistic model.</li>
</ul>
</p></div><div class="content" id="content3"><p><h2>Mobility</h2>
<p>Edit: <code>Kevin Cyu</code></p>
<hr>
<h3>Random waypoint model</h3>
<p>Random model for the movement of mobile users, and how their <code>location</code>, <code>velocity</code> and <code>acceleration</code> <strong>change</strong> over time.</p>
<p>So this part is going to simulate the status of movement of the mobile user randomly!</p>
<ul>
<li>Why this model is most popular <code>mobility model</code> for <strong>mobile ad-hoc network(MANET)</strong> routing protocol?
<ul>
<li>simplicity</li>
<li>wide availability</li>
</ul>
</li>
</ul>
<p>=&gt;
each <code>mobile node</code> in this random mobility simulation model is <code>independent</code>, and all using a <code>random</code> way to move (without any constraint); Also, its <code>destination</code>, <code>speed</code>, <code>direction</code> all using choose randomly.</p>
<p>=&gt;
In each simulation routine (i.e. tick), will let each node choose randomly on <code>destination</code>, <code>speed</code> again, until simulation clock end.</p>
<ul>
<li>Have two variation:
<ul>
<li>random walk model</li>
<li>random direction model</li>
</ul>
</li>
</ul>
</p></div><div class="content" id="content4"><p><h2>Physical Layer</h2>
<p>Edit: <code>Nuntanut Bhooanusas(Chuanjie Fu)</code></p>
<hr>
<p>There are <code>2 parts</code> in this section:</p>
<ul>
<li>SNR-based packet capture</li>
<li>Broadcast &amp; Dynamic transmission rate and power</li>
</ul>
<h3>SNR-based packet capture</h3>
<p>Signal-to noise ratio(SNR), in decibels , is a measurement between receive signals and noise signals.  For wireless communication, it can be computed by Equation N.1 to N.3. The example of SNR is given in Picture N.1</p>
<p><img src="./res/E1.jpg" alt="Equation N1"></p>
<ul>
<li>Equation N.1.</li>
</ul>
<p><img src="./res/E2.png" alt="Equation N2"></p>
<ul>
<li>Equation N.2.</li>
</ul>
<p><img src="./res/E3.png" alt="Equation N3"></p>
<ul>
<li>Equation N.3.</li>
</ul>
<p>This ratio is unreliable if it falls into 10-15 db and its poor rate is from 16 db to 24 db, whereas the rate of 24-40 db and exceeding 41 db is good and excellent respectively.</p>
<p><img src="./res/N1.png" alt="Picture N1"></p>
<ul>
<li>Picture N.1.</li>
</ul>
<p>The SNR is vital for IEEE 802.11 since if it is very low, the packet might need a re-transmission several times. Whether or not delivering a packet from source to destination will be successful is depended on transmission rate and power adjustment. The next section explains towards this adjustment.</p>
<h3>Broadcast &amp; Dynamic transmission rate and power</h3>
<p>Another thing , a transmission power , is to save energy of devices and battery life. It also affect the transmission rate. For example, when the distance of piers is small, <code>the power level will be reduced and the data rate will increase to the highest possibility such that the packet can reach the destination</code>.</p>
<p>Both the transmission power and the transmission rate is necessary for a service requirement since they can be related to packet errors during broadcasting. The further information is provided in [1].</p>
<p>[1] http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.404.5870&amp;rep=rep1&amp;type=pdf</p>
</p></div><div class="content" id="content5"><p><h2>Ad-hoc routing</h2>
<p>Edit: <code>Taku</code></p>
<hr>
<h3>Goal</h3>
<ul>
<li>Communication between wireless node without fixed infrastructure.</li>
<li>No external setup (self-configuring)</li>
<li>Often need multiple hops to reach dst</li>
</ul>
<h3>Structure</h3>
<ul>
<li>No fixed infrastructure, no prior planning and layout, but rely on self-communication between members, anytime, anywhere organization</li>
<li>Can send data by Unicast or Multicast</li>
</ul>
<h3>Routing</h3>
<ul>
<li>
<p>Route path is important(Routing process to find the route, called the Route discovery.</p>
</li>
<li>
<p>In the process of route exploration, nodes use Broadcast Route Request (RREQ) to obtain the routing path.</p>
</li>
<li>
<p>When a node intends to send a packet, but the routing table does not contain information about the destination node, the node initiates a route discovery procedure to find the routing path to the destination node.</p>
<ul>
<li>The source node sends a Route Request (RREQ) packet to start the route discovery procedure. When a relay node receives the RREQ packet, it first judges whether the RREQ packet is broadcasted. If so, it discards the RREQ packet Packet; if not, the information inside this RREQ packet is updated and the RREQ packet continues to be broadcast.</li>
<li>When the RREQ packet is sent to the destination node or the routing buffer of a certain relay node contains the information of the destination node, the node containing the information will reply a Route Reply (RREP) packet back to the startup route Explore the source node of the program.</li>
<li>RREP uses source routing policy to transmit RREP packets that contain the information of each relay node in the loopback path. The information is recorded in the header of the packet, and the RREP packet is sent back to the source node according to the information. When the source After the node receives the RREP packet, it starts to send the data packet.</li>
<li>When the connection fails (sending the packet to the next relay node fails), a Route Error (RERR) packet is generated, sent back to the source node, and the node along the route clears the routing information. When the source After the node receives RERR, it will restart the route discovery program to find a new path to replace the original path.</li>
</ul>
</li>
<li>
<p>Nodes spread widely and broadcast messages require some relay node replay (Rebroadcast), in order to make all nodes aware, but because of the node location may change, resulting in multiple replay, and then broadcast storm.</p>
</li>
<li>
<p>Power issue: related to the complexity of routing path</p>
</li>
<li>
<p>Pro-active routing protocol</p>
<ul>
<li>The active routing method first establishes routing information for any two nodes in the network. Therefore, when a new connection is established (the source node sends the packet to the destination node), routing information can be obtained in time to send the packet to the destination. Taking into account the wireless free network bandwidth is limited and high mobility, the original routing method used in the Internet to do some changes to adapt. At present, active routing protocols designed specifically for wireless networks are broadly divided into two types of routing methods: Distance vector and Link state.</li>
<li>Distance vector method is the adjacent nodes exchange each other's distance vector, after continuous exchange, this vector will record their own distance to all nodes in the network, the information is spread to the entire network, which can be calculated The best route to yourself for all the nodes in the entire network.</li>
<li>The node chooses a path with the lowest total cost (the sum of all the costs that go through the path), which is used to send the data from the source node to the destination node</li>
</ul>
</li>
</ul>
</p></div><div class="content" id="content6"><p><h2>Overlay routing protocols</h2>
<p>Edit: <code>Taku</code></p>
<h3>Define:What is an overlay network?</h3>
<ul>
<li>A network defined over another set of networks</li>
<li>The overlay addresses its own nodes</li>
<li>Links on one layer are network segments of lower
layers
<ul>
<li>Requires lower layer routing to be utilized</li>
</ul>
</li>
<li>Overlaying mechanism is called tunneling</li>
<li>Example: Virtual Private Networks(VPN)</li>
</ul>
<h3>Routing on the overlay</h3>
<p><img src="./res/R1.PNG" alt="Figure R1"></p>
<ul>
<li>The underlying network induces a complete graph of connectivity(No routing required!)
<ul>
<li>One virtual hop may be many underlying hops away.</li>
<li>Latency and cost vary significantly over the virtual links</li>
<li>State information may grow with E(n^2)</li>
</ul>
</li>
</ul>
<p><img src="./res/R2.PNG" alt="Figure R2"></p>
<ul>
<li>Overlay network users may not be directly connected to the overlay nodes</li>
<li>User must be redirected to a “close by” overlay node</li>
</ul>
<p>For more detail:
http://www-inst.eecs.berkeley.edu/~ee228a/fa03/228A03/Lecture%20Slides/routing4.pdf</p>
</p></div><div class="content" id="content7"><p><h2>MAC Layer</h2>
<p>Edit: <code>Nuntanut Bhooanusas(Chuanjie Fu)</code></p>
<hr>
<p>There are <code>2 parts</code> in this section:</p>
<ul>
<li>CSMA/CA( Carrier Sense Multiple Access with Collision Avoidance)</li>
<li>Virtual Carrier Sense and RTS-CTS-DATA-ACK</li>
</ul>
<h3>CSMA/CA( Carrier Sense Multiple Access with Collision Avoidance)</h3>
<p>CSMA is a protocol for carrier transmission in IEEE 802.11 network to protect a packet collision by listen-before-talk; this approach is nowadays applied to distributed coordination function(DCF).</p>
<p>In DCF, there are two time periods. The first one, DCF Inter-Frame Space(DIFS), is to tell a senders whether or not the medium is idle before starting sending a packet. Another one , Short Inter-Frame Space(SIFS), is a period that the medium can send the acknowledgement and will take place after the end of DIFS. The basic example is shown in Figure N.1</p>
<p><img src="./res/F1.png" alt="Figure N1"></p>
<ul>
<li>Figure N.1 Basic method of DCF.</li>
</ul>
<p>However, the method above can bring about collisions in the case that there are two or more stations sense the medium idle and try to transmit at the same time. In order to prevent this situation, the station should postpone access until the medium becomes idles and select a random backoff value. How to medium protect collisions and choose this value is fully explained in course material(Please see in the NCKU moodle)</p>
<h3>Virtual Carrier Sense and RTS-CTS-DATA-ACK</h3>
<p>RTS/CTS is defined to solve the hidden terminal problem found in wireless that use CSMA.  Importantly, the sender and receiver perform a handshake mechanism by exchanging RTS(Request to send) and CTS(Clear to send) control frame.</p>
<p>This approach will begin after waiting the DIFs time; then the sender send RTS to receiver prior to transmission of data frame. After awaiting SIFs, the receiver will respond with CTS including the successful handshake frame to make sure that the medium is reserved for transmission.</p>
<p>Moreover, RTS/CTS employs Virtual Carrier Sensing so as to inform other stations that there is packet broadcasting in the network by RTS and CTS frames including  the duration when the sender and the receiver complete the transmission.  As a result, all stations around this area will then set their NAV(Network Allocation Vector) after obtaining these frame so that they can know the period that they need to wait for the completion of the transmission.</p>
<p>The RTS/CTS mechanism is provided in Figure N.2.</p>
<p><img src="./res/F2.png" alt="Figure N2"></p>
<ul>
<li>Figure N.2 RTS/CTS Mechanism.</li>
</ul>
</p></div><div class="content" id="content8"><p><h2>Tracing the code</h2>
<h3>Workflow - sim1.m</h3>
<p>We'll have a closely look on the main program flow here, and then move to event part to have advanced appearence.</p>
<p><img src="./res/sim1.png" alt=""></p>
<ul>
<li>Result - <code>Hop Count</code></li>
</ul>
<p><img src="./res/sim1_hop_count.png" alt=""></p>
<ul>
<li>Result - <code>Response Time</code></li>
</ul>
<p><img src="./res/sim1_response_time.png" alt=""></p>
<ul>
<li>Result - <code>Success Rate</code></li>
</ul>
<p><img src="./res/sim1_success_rate.png" alt=""></p>
<h3>Workflow - sim2.m</h3>
</p></div><div class="content" id="content9"><p><h2>Event</h2>
<p>Listing all event types in simulation.</p>
<h3>Sim1</h3>
<h4>send_phy</h4>
<p>When current event's node is idle &amp; <code>nav</code> is not busy -&gt; will using this node as <code>transmitter</code></p>
<p>And then set up the other nodes as <code>receiver</code>: (2 mode)</p>
<ol>
<li><strong>broadcast</strong>
<ul>
<li>broadcast from this transmitter</li>
<li>impact all idle node (using <code>overlay</code> meachanism to identify), and those nodes will schedule a <code>recv_phy</code> event for each one of them.</li>
</ul>
</li>
<li><strong>unicast</strong>
<ul>
<li>This part will illustrate <code>unicast</code> from <em>event.node</em> to <em>event.pkt.rv</em></li>
<li>First set <code>event.pkt.rv</code> to receiver mode</li>
<li>Then set number of <code>n</code> nodes into <code>receiver mode</code></li>
</ul>
</li>
</ol>
<p>After all setting above, setup the transmitter's finish event: <code>send_phy_finish</code> ( in <code>t+txtime+eps</code> later, which <code>t+txtime</code> is <code>recv_phy</code> event )</p>
<p>Check <code>event.pkt.type</code>:</p>
<ul>
<li>= <code>rts</code>:
<ul>
<li>set timeout timer for RTS</li>
<li>schedule event <code>timeout_rts</code> after <code>t + (txtime + SIFS + cts_tx_time)*2</code></li>
<li>And record this node as pending id (waiting mode)</li>
</ul>
</li>
<li>= <code>data</code> &amp; (<code>event.pkt.rv</code> != 0):
<ul>
<li>set timeout for DATA</li>
<li>schedule event <code>timeout_data</code> after <code>t + (txtime + SIFS + ack_tx_time)*2</code></li>
</ul>
</li>
</ul>
<p>Node not <code>idle</code> or <code>nav</code> is block</p>
<ul>
<li>-&gt; schedule <code>wait_for_channel</code> after <code>t + cca_time</code></li>
<li>push it into <em>waiting queue</em></li>
</ul>
<p><img src="./res/sim1-send_phy.png" alt=""></p>
<h4>send_phy_finish</h4>
<p>Set node back into <code>idle</code> mode.</p>
<p>And then checkout this node's MAC queue -&gt;</p>
<ul>
<li>if <strong>empty</strong>, then <code>reset</code> the <em>MAC status</em></li>
<li>if <strong>non-empty</strong>, then pop out current element, and schedule <code>wait_for_channel</code> after <code>t + cca_time</code>
<ul>
<li>Make it prepare to use the radio resource!</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-send_phy_finish.png" alt=""></p>
<h4>send_mac</h4>
<ul>
<li>set <code>event.pkt.type</code> as <code>data</code></li>
<li><code>event.pkt.nav</code> equal to <code>SIFS + cts_tx_time + SIFS + tx_time(event.pkt) + SIFS + ack_tx_time</code></li>
<li>if <code>event.pkt.rv</code> != 0 (i.e. <em>unicast</em>)
<ul>
<li>then set <code>event.pkt.type</code> as <code>rts</code></li>
</ul>
</li>
<li>if this node is free, but still have packets waiting in MAC queue:
<ul>
<li>then <em>report error</em></li>
</ul>
</li>
<li>if MAC queue <code>empty</code>, and MAC status = 1
<ul>
<li>true, then push event(i.e. packet) into MAC queue</li>
<li>false, means node is busy, then schedule <code>wait_for_channel</code> event after time <code>t + cca_time</code></li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-send_mac.png" alt=""></p>
<h4>recv_mac</h4>
<p><img src="./res/sim1-recv_mac.png" alt=""></p>
<h4>recv_phy</h4>
<ul>
<li>switch to <code>idle</code> mode</li>
<li>And then check its <code>virtual collision</code>:
<ul>
<li>if <strong>occur</strong>: drop packet directly</li>
<li>if <strong>not occur</strong>:
<ul>
<li>call <code>recv_phy</code> <em><strong>function</strong></em> ( e.g. <code>recv_phy.m</code> )</li>
<li>calculate the probability of receiving process ( 0 or 1 )
<ul>
<li>if == 1
<ul>
<li>if this packet is for this node ( broadcast or unicast )
<ul>
<li>schedule <code>recv_mac</code> event !</li>
</ul>
</li>
<li>if not for this node, use its <code>nav</code>:
<ul>
<li>Update those:
<ul>
<li><code>nav.start</code> and <code>nav.end</code> of <code>event.pkt.rv</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-recv_phy.png" alt=""></p>
<h4>wait_for_channel</h4>
<ul>
<li>If node is idle and channel is free
<ul>
<li><code>true</code>:
<ul>
<li>If backoff_counter of this node &gt; 0
<ul>
<li><code>true</code>:
<ul>
<li>resume (restart) the backoff, then schedule <code>backoff</code> event after time <code>t + slot_time</code> for this node!</li>
</ul>
</li>
<li><code>false</code>:
<ul>
<li>start backoff from <code>DIFS</code> first, then schedule <code>backoff_start</code> event after time <code>t + DIFS</code> for this node!</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>false</code>:
<ul>
<li>means node is not idle, then it must be receiving process;</li>
<li>need to wait until the current process end</li>
<li>so schedule <code>wait_for_channel</code> event after <code>t + cca_time</code> again!</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-wait.png" alt=""></p>
<h4>backoff</h4>
<ul>
<li>If node is still idle &amp; channel is free (→ continue doing backoff)
<ul>
<li><code>true</code>:
<ul>
<li>If backoff_counter of node &gt; 1
<ul>
<li><code>true</code>:
<ul>
<li>decrease this counter by 1</li>
<li>and then re-schedule <code>backoff</code> event after <code>t + slot_time</code></li>
</ul>
</li>
</ul>
</li>
<li>or backoff_counter == 0 (i.e. <em>ready to send packet !</em>)
<ul>
<li>schedule <code>send_phy</code> event after time <code>t</code> for this node</li>
</ul>
</li>
</ul>
</li>
<li><code>false</code>: (i.e. node is not idle / channel is busy when backoff occur)
<ul>
<li>If backoff_counter of node &gt; 1
<ul>
<li><code>true</code>:
<ul>
<li>just decrease by 1</li>
</ul>
</li>
</ul>
</li>
<li>or == 0
<ul>
<li><code>true</code>:
<ul>
<li>start a new backoff counter, which <em><strong>more larger than</strong></em> current one! (You can see more in contention window part → MAC Layer)</li>
</ul>
</li>
</ul>
</li>
<li>If not &gt; 1, or == 0 (not match with above case)
<ul>
<li>then schedule <code>wait_for_channel</code> event after time <code>t + cca_time</code> for this node</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-bo.png" alt=""></p>
<h4>backoff_start</h4>
<p>(after waiting <code>DIFS</code>, start <code>backoff</code>!)</p>
<ul>
<li>If node is still idle, and channel is free
<ul>
<li><code>true</code>:
<ul>
<li>then schedule <code>backoff</code> event after <code>t + slot_time</code> for this node</li>
</ul>
</li>
<li><code>false</code>:
<ul>
<li>means that channel during <code>DIFS</code> becomes busy!</li>
<li>then schedule <code>wait_for_channel</code>, to wait until the channel is free.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-bos.png" alt=""></p>
<h4>timeout_rts</h4>
<ul>
<li>To begin with, Check whether or not there is a <code>pending id</code> being equal to <code>waiting RTS id</code> <code>i.e., (pending_id(i) == event.pkt.id)</code>
<ul>
<li>if so,
<ul>
<li>start re-transmit <code>i.e., retransmit(i)=retransmit(i)+1</code></li>
<li>if retransmit(i) &gt; max_retries
<ul>
<li>if so, (node i has so many to transmit RTS)
<ul>
<li>drop packet <code>retransmit(i) = 0</code> ,<code>pending_id(i) = 0</code></li>
<li>Check whether or not there are many packets waiting to be sent in queue
<ul>
<li>yes
<ul>
<li><code>mac_status(i) = 1</code></li>
<li>Schedule <code>wait_for_channel</code> event  after <code>t + cca_time</code></li>
</ul>
</li>
<li>No
<ul>
<li>mac_status(i) = 0` (cannot send RTS successfully, reset MAC layer)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>No ,
<ul>
<li>(retransmit the RTS)</li>
<li>Schedule <code>wait_for_channel</code> event  after <code>t + cca_time</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>No, display(pending id does not match the waiting RTS id)</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-timeout-rts.png" alt=""></p>
<h4>timeout_data</h4>
<p><img src="./res/sim1-timeout-data.png" alt=""></p>
<h4>timeout_rreq</h4>
<ul>
<li>Check how many pending RREQ ids are there in the node id <code>temp = find(net_pending(i).id == event.net.id)</code> <em>the function find will return a indices of non-zero element</em>
<ul>
<li>if len(temp = 0)
<ul>
<li>if yes →every RREQ is acknowledged , do nothing → return</li>
</ul>
</li>
<li>if len(temp &gt;1 )
<ul>
<li>if yes → error(“node i has more than one pending RREQs with  <code>net.id</code></li>
</ul>
</li>
<li>The RREQ is not acknowledged yet by an RREP
<ul>
<li>Start re-transmit → <code>net_pending(i).retransmit(temp) = net_pending(i).retransmit(temp) + 1</code></li>
<li>if there are so many retries → <code>net_pending(i).retransmit(temp) &gt; net_max_retries</code>
<ul>
<li>If so,
<ul>
<li>-Drop the RREQ i.e., <code>net_pending(i).id(temp)=[]</code> , <code>net_pending(i).retransmit(temp)=[]</code></li>
<li>-if network_queue is not empty (so redundant)
<ul>
<li>clear network queue →<code>net_queue(i).list(1)=[]</code></li>
<li>Schedule <code>send_net2</code> event after <code>t</code></li>
</ul>
</li>
</ul>
</li>
<li>No, retransmit RREQ by
<ul>
<li>-Schedule <code>send_mac</code> event after <code>t</code></li>
<li>-set new_id for re-transmission
<ul>
<li><code>newevent.net.id = new_id(i)</code></li>
<li><code>net_pending(i).id(temp) = newevent.net.id</code></li>
<li><code>rreq_out(i)=rreq_out(i)+1</code></li>
</ul>
</li>
<li>-Sent RREQ out via crosslayer  if type of application is defined ‘crosslayer_searching’  i.e., <code>if(strcmp(newevent.app.type, 'crosslayer_searching')-&gt;rreq_out_crosslayer(i) = rreq_out_crosslayer(i) + 1</code></li>
<li>-Set timeout timer for the retransmitted RREQ
<ul>
<li>-Schedule <code>timeout_rreq</code> event after <code>t+rreq_timeout</code></li>
<li>-Save the new id of the pending RREQ by <code>net_pending(i).id(temp)=newevent.net.id</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-timeout-rreq.png" alt=""></p>
<h4>send_net</h4>
<p><img src="./res/sim1-send_net.png" alt=""></p>
<h4>send_net2</h4>
<p><img src="./res/sim1-send_net2.png" alt=""></p>
<h4>recv_net</h4>
<ul>
<li>Decrease  time to live(TTL) by 1 unit</li>
<li>event.pkt.ttl = event.pkt.ttl - 1;
<ul>
<li>if(event.pkt.ttl&lt;0)
<ul>
<li>drop packet , return</li>
</ul>
</li>
<li>if the destination node is as same as transmission node
<ul>
<li>no action , return</li>
</ul>
</li>
<li>Check type of network layer
<ul>
<li><code>rreq</code>
<ul>
<li>Change flag of rreq_in → rreq_in(i)=rreq_in(i)+1</li>
<li>Enable rreq for crosslayer if app.type is ‘'crosslayer_searching’ i.e., <code>rreq_in_crosslayer(j) = rreq_in_crosslayer(j) + 1</code></li>
<li>if node <code>j</code> is member of the route in network
<ul>
<li>Yes, already found the route, do noting , return</li>
<li>No, append node <code>j</code> to the route i.e., <code>event.net.route = [event.net.route j]</code></li>
</ul>
</li>
<li>If node j is equal to the given destination by <code>event.net.dst</code>
<ul>
<li>Yes
<ul>
<li>node <code>j</code> am the destination of this RREQ: send RREP back</li>
<li><code>send_rrep = -1</code></li>
<li>if rrep_table is empty
<ul>
<li>yes, <code>k = 1</code> and <code>send_rrep = 1</code></li>
<li>No, rrep table is not empty ,
<ul>
<li>Check at the source whether there are saved RREQ or not()<code>if (rrep_table(j).list(k).route(1)==i)</code>
<ul>
<li>yes,
<ul>
<li>set <code>send_rrep = 1</code>, if the RREQ is table is old i.e., <code>if rrep_table(j).list(k).id &lt; event.net.id</code></li>
<li>if RREQ id in table is equal to <code>event.net.id</code>
<ul>
<li>Yes, if the matric of event.net is smaller than rreq table,<code>send_rrep = 1</code>, Otherwise, <code>send_rrep = 0</code> <code>//not a better route: ignore</code></li>
</ul>
</li>
<li>No,  <code>send_rrep = 0</code> <code>//reply to the newer</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>If <code>send_rrep != 0</code>
<ul>
<li>Yes, Change flag rrep_out → <code>rrep_out(j) = rrep_out(j) + 1</code>
<ul>
<li>rrep_out_crosslayer(j) = rrep_out_crosslayer(j) + 1 if event.app.type = 'crosslayer_searching'</li>
<li>if(<code>send_rrep&lt;0)</code> → k = length(rrep_table(j).list) + 1 — no early saved RREQ from this src: add one</li>
<li>initialize <code>rreq_table</code></li>
<li>Schedule <code>send_mac</code> event after <code>t</code></li>
<li>newevent.net.type =<code>'rrep'</code></li>
<li>newevent.pkt.type=<code>'data'</code>;</li>
<li>newevent.pkt.tx = j;</li>
<li>newevent.pkt.rv = newevent.net.route(temp - 1); % next hop</li>
<li>newevent.pkt.id=0   -- will be updated in 'send_phy'</li>
<li>newevent.pkt.nav=0; -- will be updated in lower layer</li>
<li>return</li>
</ul>
</li>
</ul>
</li>
<li>No,  do nothing ,return</li>
</ul>
</li>
</ul>
</li>
<li>Node j is not the destination of the RREQ , re-broadcast it</li>
<li>if event.pkt.ttl&lt;0
<ul>
<li>Yes, drop it ,return</li>
<li>No,
<ul>
<li>if event.net.id &gt; bcast_table(j, event.net.src)
<ul>
<li>Yes, forward this RREQ only if meduim have not forwarded the same broadcast RREQ from the same source before</li>
<li>Enable rreq for crosslayer if app.type is ‘'crosslayer_searching’ i.e.,<code>rreq_forward_crosslayer(j) = rreq_forward_crosslayer(j) + 1</code></li>
<li>update braodcast table <code>bcast_table(j, event.net.src) = event.net.id</code></li>
<li>Schedule <code>send_mac</code> event after <code>t + rand*slot_time</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>rrep</code>
<ul>
<li>Change flag of rrep_in → rrep_in(i)=rrep_in(i)+1</li>
<li>Enable rrep for crosslayer if app.type is ‘'crosslayer_searching’ i.e.,<code>rrep_in_crosslayer(j) = rrep_in_crosslayer(j) + 1</code></li>
<li>If route is empty , return — node j is receiving a RREP without any route entry</li>
<li>temp = find(event.net.route == j) — examine node j is in the route or not
<ul>
<li>If there are node J more than once in route(RREP) ,  do noting , return</li>
<li>If there is node J more than once in route(RREP), do nothing, return</li>
<li>if the number of node J == 1
<ul>
<li>Yes //find the requesting node so this RREP is suspected
<ul>
<li>Check how many RREQ in the route</li>
<li><code>(temp2 = find(net_pending(j).id == event.net.id)</code>
<ul>
<li>if there is no RREQ , node j receives an RREP without a corresponding pending RREQ, return</li>
<li>if there are RREQ more than once in the route, return</li>
</ul>
</li>
<li>Removes the pending RREQ
<ul>
<li>net_pending(j).id(temp2) = []</li>
<li>net_pending(j).retransmit(temp2) = []</li>
</ul>
</li>
<li>If event.app.type = ‘crosslayer_searching’
<ul>
<li>Yes
<ul>
<li><code>rrep_destination_crosslayer(j) = rrep_destination_crosslayer(j) + 1</code></li>
<li>Schedule <code>recv_app</code> event after <code>t</code></li>
</ul>
</li>
<li>No
<ul>
<li>Schedule <code>send_mac</code> event after <code>t</code></li>
<li>newevent.net.type =<code>'data'</code></li>
<li>newevent.net.id = <code>new_id(j)</code></li>
<li>newevent.pkt.tx = j;</li>
<li>newevent.pkt.rv = newevent.net.route(temp - 1); % next hop</li>
<li>newevent.pkt.type=<code>'data'</code>;</li>
<li>newevent.pkt.id=0   -- will be updated in 'send_phy'</li>
<li>newevent.pkt.nav=0; -- will be updated in lower layer</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>No,
<ul>
<li>Schedule <code>send_mac</code> event after <code>t</code></li>
<li>newevent.net.type =<code>'rrep'</code></li>
<li>newevent.pkt.tx = j;</li>
<li>newevent.pkt.rv = newevent.net.route(temp - 1); % next hop</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>data</code>
<ul>
<li>if (event.net.dst == 0)
<ul>
<li>Yes, <code>//a network layer broadcast packet</code>
<ul>
<li>if event.pkt.rv != 0, waring <code>node j receives a broadcast at NET, but not at MAC</code></li>
<li>if event.net.id is new than bcast_table(j, event.net.src)
<ul>
<li>update bcast_table(j, event.net.src) = event.net.id</li>
<li>Schedule <code>send_mac</code> event after <code>t + rand*slot_time</code></li>
</ul>
</li>
<li>return</li>
</ul>
</li>
</ul>
</li>
<li>if route is empty <code>//receives a unicast data packet at network layer</code>
<ul>
<li>‘Node j is receiving a Net_DATA without any route entry` , return</li>
</ul>
</li>
<li>temp = find(event.net.route == j) <code>// find there are node j in the route or not</code></li>
<li>if find node <code>j</code> more than once in the data packet, return</li>
<li>if there is no node <code>j</code> in the data packet, return</li>
<li>if node <code>j</code> is the destination
<ul>
<li>Yes
<ul>
<li>Schedule <code>recv_app</code> event after <code>t</code></li>
</ul>
</li>
<li>No
<ul>
<li>Schedule <code>send_mac</code> event after <code>t</code></li>
<li>newevent.pkt.tx = j;</li>
<li>newevent.pkt.rv = newevent.net.route(temp + 1)</li>
<li><code>Forward this data packet to the next hop towards the destination</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-recv_net.png" alt=""></p>
<h4>send_app</h4>
<ul>
<li>Check type of application layer <code>event.app.type</code>
<ul>
<li>Crosslayer_Searching
<ul>
<li>node i sends a a crosslayer searching request for key(node) e.g.,<code>event.app.key</code></li>
<li>Schedule <code>send_net</code> event</li>
<li>from source <code>newevent.net.src = i</code> to destination <code>newevent.net.dst = newevent.app.key</code></li>
</ul>
</li>
<li>dht_serching
<ul>
<li>Schedule <code>send_net</code></li>
<li>check whether or not there is dht overlay route →(<code>if isempty(newevent.app.route)</code>)
<ul>
<li>No,
<ul>
<li>initialize dht overlay searching
<ul>
<li>-newevent.app.route = [i]</li>
<li>-random one node for build the path →( tempn = floor(rand*log2(n));)</li>
<li>if tempn &gt; 0
<ul>
<li>Random node again by <code>tempx = ceil(rand*n)</code>
<ul>
<li>if the destination (newevent.app.route newevent.app.key) have never made as route i.e,<code>if isempty(find([newevent.app.route newevent.app.key]==tempx))</code>
<ul>
<li>-use app.key as the destination of node i i.e., <code>newevent.app.route = [newevent.app.route newevent.app.key]</code> ,<code>newevent.net.dst = newevent.app.route(2)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Undefined type
<ul>
<li>display (Undefined application layer type) → end</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./res/sim1-send_app.png" alt=""></p>
<h4>recv_app</h4>
<p><img src="./res/sim1-recv_app.png" alt=""></p>
</p></div><div class="content" id="content10"><p><h2>Utility</h2>
<p>Some other source code like <code>recv_phy.m</code>, <code>recv_power.m</code> ...  will be discussed here.</p>
<h3>recv_phy.m</h3>
<p>Calculate the power receive by current node. (with <code>SNR</code>)</p>
<ul>
<li>transmition node: <code>event.pkt.tx</code></li>
<li>receiving node: <code>event.pkt.rv</code></li>
</ul>
<pre><code class="language-c">Pr0 = recv_power(tx, rv, rmodel);
Pr = 0;
I = find(node(:, 3)&gt;0);
for i=1:length(I)
   tx1 = I(i);
   if tx1 == rv, continue; end
   if tx1 == tx, continue; end
   Pr = Pr + recv_power(tx1, rv, rmodel);
end

N0 = white_noise_variance;
SNR = db(Pr0/(Pr+N0), 'power');

% Return with Pr0 and SNR
return;
</code></pre>
<p>Then calling <code>recv_power.m</code> to get the power value.</p>
<p>See more in <code>02-3-PHY</code> to see the detail.</p>
<hr>
<h3>recv_power.m</h3>
<p>Choosing model from <strong>Radio propagation</strong> ( <code>friis(free space)</code>, <code>two-ray</code>, <code>shadowing</code> ), this program using <code>shadowing</code> as default value.</p>
<p>Before calculating the power, call <code>position_update.m</code> to refresh the position of each node.</p>
<pre><code class="language-c">switch rmodel
    case 'friis'
        Pr = friis(Pt, Gt, Gr, lambda, L, d);
    case 'tworay'
        [Pr, crossover_dist] = tworay(Pt, Gt, Gr, lambda, L, ht, hr, d);
    case 'shadowing'
        Pr = log_normal_shadowing(Pt, Gt, Gr, lambda, L, pathLossExp, std_db, d0, d);
end
</code></pre>
<p>See more in <code>02-1-Radio</code> to see the detail.</p>
<hr>
<h3>inv_recv_power.m</h3>
<p>Inverse version of recv_power, using the power to get the corresponding <code>distance</code>.</p>
</p></div></div></div><div class="row flex-right"><p>Created by <span class="badge secondary">@ToolBuddy/@papercss</span></p></div></div></div></body></html>